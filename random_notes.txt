Główna dokumentacja jest w dokumencie na google-docsach:
https://docs.google.com/document/d/10MbrynYjchbdK_8ktb1hMgdaupQAVE-z4DZIZ5x-Pts/edit

Wymiary kafli: 24x24 (dwukrotnie powiększone)
  niektóre sprite-y na kaflach wystają poza region samego kafla
  np. drzewka albo niektóre postacie wystają trochę z góry

Ficzery systemu animacji:
- Są różne rodzaje spawnowalnych efektów:
  - relatywne: magiczny efekt podpięty do jakiejś postaci; jak postać się
    przesuwa, to particle przesuwają się wraz z nią
  - absolutne: jeśli zmienimy pozycję efektu, to stare cząsteczki zostają
    na swoim miejscu
  - to można zrobić per-sub-system
- niektóre efekty mogą być w ciekawy sposób animowane przez czas ich trwania
  ale mogą mieć inną animację pojawiania się i znikania?
- możliwość odgrywania animacji od środka (z już z kilkoma zrespawnowanymi cząsteczkami
  na odpowiednich pozycjach); To może wymagać całkowania niektórych krzywych i systemów
  akumulacji rotacji, pozycji etc.
- możliwość używanie cząsteczek z jednego podsystemu jako emiterów do drugiego podsystemu
  tutaj wystarczy, jeśli funkcje emitujące będą miały odpowiednio szeroki kontekst
  (w EmitterState jest np. indeks aktualnego podsystemu i referencja do definicji / stanu subsystemu?)
- różne kształty emitera
- możliwość wyłaczenia animacji w taki sposób, że emitery przestają działać, ale te cząsteczki które
  już zostały wygenerowane mogą skończyć animację

Potencjalny problem:
- jak dobrze uniezależnić efekty od FPSów ?

---- Pomysły na efekty:

Animacja kręgów na wodzie:
- to chyba nie ma sensu, jeśli sama woda nie jest animowana
- zamiast tego możemy zrobić splash, to powinno sie lepiej komponować
  ze statyczną teksturą wody
  Chyba, że byśmy zanimowali wodę...


	Niektóre efekty można animować tylko w momencie zaaplikowania
	(tak, żeby w przypadku dużej ilości efektów nie było za dużo fxów)
	FXy widoczne tylko w momencie aplikacji efektu:
    DAM_BONUS, 	 		   //
    DEF_BONUS,  		   //
    POISON_RESISTANT,	   //
    FIRE_RESISTANT,  	   //
	SLEEP_RESISTANT,
    MAGIC_RESISTANCE,
    MELEE_RESISTANCE,
    RANGED_RESISTANCE,
    MAGIC_VULNERABILITY,
    MELEE_VULNERABILITY,
    RANGED_VULNERABILITY,

	Efekty o stanie umysłu: jakieś particle nad głową
    PANIC,        // jakiś symbol oznaczający strach i panikę ?
    INSANITY,     // pioruny nad głową (coś jak berserk w innych grach)
    PEACEFULNESS, // ???
    SLEEP,        // ZZZ

	Efekty w pobliżu stóp:
    SLOWED,     // 
    SPEED,      // 
    FLYING,     // 

    RAGE,         // krwawy kolor
    BLEEDING,     // generowanie śladów krwi na tile-ach (im dłużej się jest na danym kaflu tym większa plama)
    HALLU,        // ???
    BLIND,        // pulsujący kołowy efekt nad głową postaci
    INVISIBLE,    // bez efektu: postać jest przezroczysta ?
    POISON,       // zielony overlay postaci ?
    ENTANGLED,    // jakieś fajne particle bluszczu
    TIED_UP,      // czym to się różni od entangled ?
    STUNNED,      // podobnie jak blind, trochę inny efekt
    REGENERATION, // 
    WARNING,
    TELEPATHY,
    SUMMONED

	Brak wizualizacji:
    COLLAPSED,
    SATIATED,
    LIGHT_SOURCE,
    DARKNESS_SOURCE,
    ELF_VISION,
    NIGHT_VISION,
    SUNLIGHT_VULNERABLE,
    PREGNANT,
    RESTED,

-------------------------------------------------------------------------------


Mini todo:
- zapisywanie do pliku & hot reloading
- zainspirować się efektami z innych gier
- jakoś opisać udostępniane przez efekty parametry ?
- możliwość wizualizacji krzywych chyba jednak się przyda
- różne rodzaje spawnerów ?
- efekty bazujące na blockerach
- update dokumentu na google docsach

Integracja libfwk:
- Problem: libfwk działa bez wyjątków (kompilacja zakłada, że są wyłączone); Jeśli libfwk
  jest używane tylko do edytora cząsteczek, to nie powinno to stanowić problemu

 
Zapisywanie do pliku:
- chcemy zapisywać w wygodnej formie tekstowej, którą można łatwo edytować
- możemy użyć Cereal i zapisać do XMLa
- Opcja: cereal

- Jak chcielibyśmy, żeby to było zapisane ?

  to chyba jednak najłatwiej się definiuje z kodu...
  zrobienie parsera trochę czasu zajmie;
  najszybciej by chyba było z cerealem i xmlem / jsonem...
